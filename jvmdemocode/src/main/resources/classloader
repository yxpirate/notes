一，
类加载
在Java代码中，类型(Object本身,一个class，不是object对象)的加载，链接与初始化过程都是在程序运行期间完成的
JVM规范允许类加载器在预料某个类将要被使用时就预先加载它
如果在预先加载的过程中遇到.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时报告错误（LinkageError）


加载：将类的.class文件从磁盘加载到内存,将其放在运行时数据区的方法区内，
     然后在内存中创建一个Java.lang.Class对象，
	 用来封装类在方法区内的数据结构
链接：类与类之间的关系处理
     1）验证：确保被加载的类的正确性
     2）准备：为类的静态变量分配内存，并设置默认值。但是在初始化之前，类变量都没有初始化为真正的初始值
     3）解析：把类中的符号引用转换为直接引用
初始化：为类的静态变量赋予正确的初始值
		静态变量初始化的两种途径:(虚拟机按照语句在类文件中的先后顺序来依次执行)
		1)在静态变量的声明处进行初始化(public static int a = 1;)
		2)在静态代码块中进行初始化
		public static int b;
		statuc {b = 2};
使用：
卸载：

二，
java类的主动使用(会导致类的初始化)：
1，创建类的实例，new Object()
2，访问某个类或接口的静态变量，或者对该静态变量赋值
3，调用类的静态方法
4，反射，Class.forName("包全类名")
5，初始化一个类的子类
6，Java虚拟机启动时被标明,为启动类的类，(main方法)
7，jdk1.7后提供的动态语言支持


三，
类实例化
为新的对象分配内存
为实例变量赋默认值
为实例变量赋正确初始值
java编译器为它编译的每一个类都至少生成一个实例初始化方法


四，类加载器(并不需要等到某个类被"首次主动使用"时再加载它)
两种类型
1，Java虚拟机自带的加载器
根类加载器(Bootstrap)
扩展类加载器(Extension)
系统(应用)类加载器(System)
2，自定义的类加载器
java.lang.ClassLoader的子类


五，类加载器命名空间
每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成



当前类加载器
每个类都会使用自己的类加载器(即加载自身的类加载器)来去加载其他类(指的是所依赖的类)，
如果ClassX引用了ClassY，那么ClassX的类加载器就会去加载ClassY(前提是ClassY尚未被加载)

线程上下文类加载器
线程上下文类加载器是从JDK1.2开始引入的，类Thread中的getContextClassLoader()和setContextClassLoader()
分别用来获取和设置上下文类加载器。

如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。
Java应用运行时的初始线程的上下文类加载器是系统类加载器。
在线程中运行的代码可以通过该类加载器来加载类与资源

父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指的的classLoader加载
的类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的ClassLoader加载的类的
情况，即改变了双亲委托模型。

线程上下文类加载器就是当前线程的当前类加载器

SPI(Service Provider Interface)
在双亲委托模型下，类加载时由下至上的，即下层的类加载器会委托上层进行加载。但对于SPI来说，有些接口是Java核心库所提供的，
而Java核心库是由启动类加载器加载的，而这些接口的实现却来自于不同的jar包(厂商提供)，java的启动类加载器是不会加载其他来
源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。而通过给当前线程设置上下文类加载器，就可以有设置的上下文类加载器来实现对接口实现类的加载。